Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># RA Duty Scheduler\r\n# Copyright (c) 2021, David Peterson\r\n#\r\n# All rights reserved.\r\n\r\n# import statements\r\nimport calendar\r\nimport pandas as pd\r\nimport sys\r\nimport random\r\nimport os\r\n\r\nfrom datetime import datetime\r\nfrom RA import ResidentAdviser\r\nfrom mplcal import MplCalendar\r\n\r\n# constants\r\nYEAR = datetime.today().year\r\nWEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday']\r\nWEEKENDS = ['Friday', 'Saturday']\r\nNUM_DAYS_YEAR = 365\r\n\r\n# determine if scheduling for the current month or the next month\r\nMONTH_SELECT = input(\"Would you like to schedule for the CURRENT (c) month or the NEXT (n) month? [c/n]: \")\r\nif MONTH_SELECT == 'c':\r\n    MONTH_SELECT_NUM = 0\r\nelif MONTH_SELECT == 'n':\r\n    MONTH_SELECT_NUM = 1\r\nelse:\r\n    print(\"ERROR: Please enter 'c' for the CURRENT month or 'n' for the NEXT month.\")\r\n    sys.exit(1)\r\n\r\n# setting number of RAs on duty weekday/weekend\r\nWEEKDAY_STAFF_NUM = int(input(\"How many RAs would you like scheduled on weekdays (Sun-Thurs)? (between 0 and 3): \"))\r\nWEEKEND_STAFF_NUM = int(input(\"How many RAs would you like scheduled on weekends (Fri-Sat)? (between 0 and 3): \"))\r\nif not (0 <= WEEKDAY_STAFF_NUM <= 3) or not (0 <= WEEKEND_STAFF_NUM <= 3):\r\n    print(\"ERROR: Program only schedules between 0 and 3 RAs for weekdays/weekends.\")\r\n    sys.exit(1)\r\n\r\n# month number and string\r\nMONTH_NUM = datetime.today().month + MONTH_SELECT_NUM % 12\r\nMONTH_STRING = calendar.month_name[MONTH_NUM]\r\n\r\n# number of days in current month\r\nNUM_DAYS_MONTH = calendar.monthrange(datetime.today().year, datetime.today().month + MONTH_SELECT_NUM % 12)[1]\r\n\r\n# schedule bounds - useful for partial months of duty scheduling\r\nSCHEDULE_START_DAY = 1\r\nMONTH_END_DAY = NUM_DAYS_MONTH\r\n\r\n# dictionary to hold names of RA scheduled for each date\r\nschedule_dict = {}\r\n\r\nfor i in range(NUM_DAYS_MONTH):\r\n    schedule_dict[i + 1] = ['RA']\r\n\r\n# read and create Pandas data frame from Availability XLSX file\r\nBUILDING = input(\"Input the building/community code (NHW, CHRNE_HARP, etc.): \").upper()\r\nAVAILABILITY_FILE_PATH = \"Availability/\" + MONTH_STRING + \"_\" + BUILDING + \".xlsx\"\r\nif not os.path.isfile(AVAILABILITY_FILE_PATH):\r\n    print(\"Incorrect Availability file path. Check that the input file path exists and contains the correct month/building format.\")\r\n    print(\"Format example: monthName_buildingCode.xlsx\")\r\n    sys.exit(1)\r\navailability_master = pd.DataFrame(pd.read_excel(AVAILABILITY_FILE_PATH))\r\n\r\n# read and create Pandas data frame from History XLSX file\r\nHISTORY_FILE_PATH = \"History/\" + BUILDING + \"_hist.xlsx\"\r\nif not os.path.isfile(HISTORY_FILE_PATH):\r\n    print(\"Incorrect History file path. Check that the input file path exists and contains the correct building format.\")\r\n    print(\"Format example: buildingCode_hist.xlsx\")\r\n    sys.exit(1)\r\nhistory_master = pd.DataFrame(pd.read_excel(HISTORY_FILE_PATH))\r\n\r\n# list of RA names from Availability XLSX file, cumulative weekdays, cumulative weekends, cumulative partnerships\r\nRA_NAMES = availability_master[\"First Name\"].tolist()\r\nRA_CUM_WEEKDAYS = history_master[\"Weekdays Total\"].tolist()\r\nRA_CUM_WEEKENDS = history_master[\"Weekends Total\"].tolist()\r\n\r\n# list of days the RA's are busy\r\nRA_BUSY_DAYS = availability_master[\"Days\"].tolist()\r\n\r\n# number of days in current month\r\nNUM_DAYS_MONTH = calendar.monthrange(datetime.today().year, datetime.today().month + MONTH_SELECT_NUM % 12)[1]\r\n\r\n# while the user is not satisfied with the duty schedule, create new versions\r\nuser_satisfied = 'n'\r\n\r\nwhile user_satisfied == 'n':\r\n    # create RA object from ResidentAdviser class for each RA in Availability XLSX file\r\n    RA_DETAILS = {}\r\n    for i in range(len(RA_NAMES)):\r\n        days_ints = []\r\n        days_ints_strings = []\r\n        availability_excel = []\r\n        days_strings = RA_BUSY_DAYS[i]\r\n\r\n        # parse Google form output for RA availability\r\n        if isinstance(days_strings, str):\r\n            days_strings_split = days_strings.split(\"/\")\r\n\r\n            for j in range(len(days_strings_split)):\r\n                if j % 2:\r\n                    days_ints_strings.append(days_strings_split[j])\r\n\r\n        for k in range(len(days_ints_strings)):\r\n            days_ints.append(int(days_ints_strings[k]))\r\n\r\n        for day in range(1, NUM_DAYS_MONTH + 1):\r\n            if day not in days_ints:\r\n                availability_excel.append(day)\r\n\r\n        RA_DETAILS[RA_NAMES[i]] = ResidentAdviser(RA_NAMES[i], availability_excel, RA_CUM_WEEKDAYS[i], RA_CUM_WEEKENDS[i])\r\n\r\n    # determine candidates for scheduling on each day of the current month + schedule accordingly based on availability\r\n    for DAY_NUM in range(SCHEDULE_START_DAY - 1, MONTH_END_DAY):\r\n        count_threshold = NUM_DAYS_YEAR\r\n        candidates = []\r\n        candidate_selected = None\r\n        candidate_guaranteed = None\r\n        weekday_boolean = True\r\n\r\n        # candidate selection\r\n        if calendar.day_name[datetime(YEAR, MONTH_NUM, DAY_NUM + 1).weekday()] in WEEKDAYS:\r\n            weekday_boolean = True\r\n            for keys, RA in RA_DETAILS.items():\r\n                if RA.scheduled_weekdays < count_threshold:\r\n                    count_threshold = RA.scheduled_weekdays\r\n            while len(candidates) < WEEKDAY_STAFF_NUM:\r\n                for keys, RA in RA_DETAILS.items():\r\n                    if RA.scheduled_weekdays <= count_threshold and DAY_NUM + 1 in RA.availability_clean and RA.name not in candidates:\r\n                        if DAY_NUM:\r\n                            if RA.name not in schedule_dict[DAY_NUM]:\r\n                                candidates.append(RA.name)\r\n                        else:\r\n                            candidates.append(RA.name)\r\n                if len(candidates) == 1 and not candidate_guaranteed:\r\n                    candidate_guaranteed = candidates[0]\r\n                count_threshold += 1\r\n\r\n                if count_threshold == NUM_DAYS_YEAR:\r\n                    print(\"NOT ENOUGH CANDIDATES FOR \" + MONTH_STRING + \" \" + str(DAY_NUM + 1) + \" (WEEKDAY) - Currently have \" + str(len(candidates)) + \" candidate(s) | Candidate(s): \" + str(candidates))\r\n                    sys.exit(1)\r\n\r\n            # update partnerships\r\n            if len(candidates) == WEEKDAY_STAFF_NUM:\r\n                if WEEKEND_STAFF_NUM > 1:\r\n                    for i in range(len(candidates)):\r\n                        if not i and candidates[i] not in RA_DETAILS[candidates[0]].partnerships:\r\n                            RA_DETAILS[candidates[0]].partnerships.append(candidates[i])\r\n                            RA_DETAILS[candidates[i]].partnerships.append(candidates[0])\r\n                else:\r\n                    pass  # no partnerships updated if alone\r\n\r\n                # update weekday counts\r\n                for i in range(len(candidates)):\r\n                    RA_DETAILS[candidates[i]].scheduled_weekdays += 1\r\n\r\n                # append RA names to the schedule management dictionary\r\n                candidates_selected = []\r\n                for i in range(len(candidates)):\r\n                    candidates_selected.append(candidates[i])\r\n\r\n                schedule_dict[DAY_NUM + 1] = candidates_selected\r\n\r\n            # scheduling process\r\n            elif len(candidates) > WEEKDAY_STAFF_NUM:\r\n                candidate_selection = random.sample(range(0, len(candidates)), len(candidates))\r\n                if not candidate_guaranteed:\r\n                    candidates_selected = [candidates[candidate_selection[0]]]\r\n                    for index in range(1, len(candidate_selection)):\r\n                        if len(candidates_selected) != WEEKDAY_STAFF_NUM:\r\n                            if candidates[candidate_selection[index]] not in RA_DETAILS[candidates[candidate_selection[0]]].partnerships:\r\n                                RA_DETAILS[candidates[candidate_selection[0]]].partnerships.append(candidates[candidate_selection[index]])\r\n                                RA_DETAILS[candidates[candidate_selection[index]]].partnerships.append(candidates[candidate_selection[0]])\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n                    if len(candidates_selected) != WEEKDAY_STAFF_NUM:\r\n                        for index in range(1, len(candidate_selection)):\r\n                            if candidates[candidate_selection[index]] not in candidates_selected and len(candidates_selected) != WEEKDAY_STAFF_NUM:\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n\r\n                    # update weekday counts\r\n                    for i in range(len(candidates_selected)):\r\n                        RA_DETAILS[candidates[candidate_selection[i]]].scheduled_weekdays += 1\r\n\r\n                    # append RA names to the schedule management dictionary\r\n                    schedule_dict[DAY_NUM + 1] = candidates_selected\r\n                else:\r\n                    candidates_selected = []\r\n                    for index in range(0, len(candidate_selection)):\r\n                        if len(candidates_selected) != WEEKDAY_STAFF_NUM-1:\r\n                            if candidates[candidate_selection[index]] not in RA_DETAILS[candidate_guaranteed].partnerships \\\r\n                                    and not candidate_guaranteed == candidates[candidate_selection[index]]:\r\n                                RA_DETAILS[candidate_guaranteed].partnerships.append(candidates[candidate_selection[index]])\r\n                                RA_DETAILS[candidates[candidate_selection[index]]].partnerships.append(candidate_guaranteed)\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n                    if len(candidates_selected) != WEEKDAY_STAFF_NUM-1:\r\n                        for index in range(0, len(candidate_selection)):\r\n                            if candidates[candidate_selection[index]] not in candidates_selected and len(candidates_selected) != WEEKDAY_STAFF_NUM-1 \\\r\n                                    and not candidate_guaranteed == candidates[candidate_selection[index]]:\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n\r\n                    # update weekday counts\r\n                    for i in range(len(candidates_selected)):\r\n                        RA_DETAILS[candidate_guaranteed].scheduled_weekdays += 1\r\n                        RA_DETAILS[candidates[candidate_selection[i]]].scheduled_weekdays += 1\r\n\r\n                    # append RA names to the schedule management dictionary\r\n                    candidates_selected.append(candidate_guaranteed)\r\n                    schedule_dict[DAY_NUM + 1] = candidates_selected\r\n        elif calendar.day_name[datetime(YEAR, MONTH_NUM, DAY_NUM + 1).weekday()] in WEEKENDS:\r\n            weekday_boolean = False\r\n            for keys, RA in RA_DETAILS.items():\r\n                if RA.scheduled_weekends < count_threshold:\r\n                    count_threshold = RA.scheduled_weekends\r\n            while len(candidates) < WEEKEND_STAFF_NUM:\r\n                for keys, RA in RA_DETAILS.items():\r\n                    if RA.scheduled_weekends <= count_threshold and DAY_NUM + 1 in RA.availability_clean and RA.name not in candidates:\r\n                        if DAY_NUM:\r\n                            if RA.name not in schedule_dict[DAY_NUM]:\r\n                                candidates.append(RA.name)\r\n                        else:\r\n                            candidates.append(RA.name)\r\n                if len(candidates) == 1 and not candidate_guaranteed:\r\n                    candidate_guaranteed = candidates[0]\r\n                count_threshold += 1\r\n\r\n                if count_threshold == NUM_DAYS_YEAR:\r\n                    print(\"NOT ENOUGH CANDIDATES FOR \" + MONTH_STRING + \" \" + str(DAY_NUM + 1) + \" (WEEKEND) - Currently have \" + str(len(candidates)) + \" candidate(s) | Candidate(s): \" + str(candidates))\r\n                    sys.exit(1)\r\n\r\n            # update partnerships\r\n            if len(candidates) == WEEKEND_STAFF_NUM:\r\n                if WEEKEND_STAFF_NUM > 1:\r\n                    for i in range(len(candidates)):\r\n                        if not i and candidates[i] not in RA_DETAILS[candidates[0]].partnerships:\r\n                            RA_DETAILS[candidates[0]].partnerships.append(candidates[i])\r\n                            RA_DETAILS[candidates[i]].partnerships.append(candidates[0])\r\n                else:\r\n                    pass  # no partnerships updated if alone\r\n\r\n                # update weekend counts\r\n                for i in range(len(candidates)):\r\n                    RA_DETAILS[candidates[i]].scheduled_weekends += 1\r\n\r\n                # append RA names to the schedule management dictionary\r\n                candidates_selected = []\r\n                for i in range(len(candidates)):\r\n                    candidates_selected.append(candidates[i])\r\n\r\n                schedule_dict[DAY_NUM + 1] = candidates_selected\r\n\r\n            # scheduling process\r\n            elif len(candidates) > WEEKEND_STAFF_NUM:\r\n                candidate_selection = random.sample(range(0, len(candidates)), len(candidates))\r\n                if not candidate_guaranteed:\r\n                    candidates_selected = [candidates[candidate_selection[0]]]\r\n                    for index in range(1, len(candidate_selection)):\r\n                        if len(candidates_selected) != WEEKEND_STAFF_NUM:\r\n                            if candidates[candidate_selection[index]] not in RA_DETAILS[candidates[candidate_selection[0]]].partnerships:\r\n                                RA_DETAILS[candidates[candidate_selection[0]]].partnerships.append(candidates[candidate_selection[index]])\r\n                                RA_DETAILS[candidates[candidate_selection[index]]].partnerships.append(candidates[candidate_selection[0]])\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n                    if len(candidates_selected) != WEEKEND_STAFF_NUM:\r\n                        for index in range(1, len(candidate_selection)):\r\n                            if candidates[candidate_selection[index]] not in candidates_selected and len(candidates_selected) != WEEKEND_STAFF_NUM:\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n\r\n                    # update weekend counts\r\n                    for i in range(len(candidates_selected)):\r\n                        RA_DETAILS[candidates[candidate_selection[i]]].scheduled_weekends += 1\r\n\r\n                    # append RA names to the schedule management dictionary\r\n                    schedule_dict[DAY_NUM + 1] = candidates_selected\r\n                else:\r\n                    candidates_selected = []\r\n                    for index in range(0, len(candidate_selection)):\r\n                        if len(candidates_selected) != WEEKEND_STAFF_NUM - 1:\r\n                            if candidates[candidate_selection[index]] not in RA_DETAILS[candidate_guaranteed].partnerships \\\r\n                                    and not candidate_guaranteed == candidates[candidate_selection[index]]:\r\n                                RA_DETAILS[candidate_guaranteed].partnerships.append(candidates[candidate_selection[index]])\r\n                                RA_DETAILS[candidates[candidate_selection[index]]].partnerships.append(candidate_guaranteed)\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n                    if len(candidates_selected) != WEEKEND_STAFF_NUM - 1:\r\n                        for index in range(0, len(candidate_selection)):\r\n                            if candidates[candidate_selection[index]] not in candidates_selected and len(candidates_selected) != WEEKEND_STAFF_NUM - 1 \\\r\n                                    and not candidate_guaranteed == candidates[candidate_selection[index]]:\r\n                                candidates_selected.append(candidates[candidate_selection[index]])\r\n                                break\r\n\r\n                    # update weekend counts\r\n                    for i in range(len(candidates_selected)):\r\n                        RA_DETAILS[candidate_guaranteed].scheduled_weekends += 1\r\n                        RA_DETAILS[candidates[candidate_selection[i]]].scheduled_weekends += 1\r\n\r\n                    # append RA names to the schedule management dictionary\r\n                    candidates_selected.append(candidate_guaranteed)\r\n                    schedule_dict[DAY_NUM + 1] = candidates_selected\r\n\r\n    # confirm correct names scheduled for correct dates\r\n    print(\"RAs Scheduled Dates\")\r\n    for keys, RA in schedule_dict.items():\r\n        print(keys, RA)\r\n    print(\"-------------------------------------------\")\r\n\r\n    # confirm even distribution of worked day amounts/types\r\n    print(\"RA Weekday/Weekend Counts\")\r\n    for keys, RA in RA_DETAILS.items():\r\n        print(RA.name + \" | Weekdays: \" + str(RA.scheduled_weekdays) + \" | Weekends: \" + str(RA.scheduled_weekends))\r\n    print(\"-------------------------------------------\")\r\n\r\n    # view partnerships for each RA for the given month\r\n    print(\"RA Partnerships\")\r\n    for keys, RA in RA_DETAILS.items():\r\n        print(RA.name + \" | Partnerships: \" + str(RA.partnerships) + \" | \" + str(len(RA.partnerships)) + \"/\" + str(len(RA_NAMES) - 1) + \" RAs\")\r\n    print(\"-------------------------------------------\")\r\n\r\n    # view RA availability count for each RA for the given month\r\n    print(\"RA Availability\")\r\n    for keys, RA in RA_DETAILS.items():\r\n        print(RA.name + \" | Availability: \" + str(len(RA.availability_clean)) + \"/\" + str(NUM_DAYS_MONTH) + \" days\")\r\n    print(\"-------------------------------------------\")\r\n\r\n    # create calendar with names of RAs on duty labeled on respective date\r\n    calendar_create = MplCalendar(YEAR, MONTH_NUM)\r\n    for DAY_NUM in range(SCHEDULE_START_DAY - 1, MONTH_END_DAY):\r\n        if calendar.day_name[datetime(YEAR, MONTH_NUM, DAY_NUM + 1).weekday()] in WEEKDAYS:\r\n            for i in range(WEEKDAY_STAFF_NUM):\r\n                calendar_create.add_event(DAY_NUM + 1, schedule_dict[DAY_NUM + 1][i])\r\n        elif calendar.day_name[datetime(YEAR, MONTH_NUM, DAY_NUM + 1).weekday()] in WEEKENDS:\r\n            for i in range(WEEKEND_STAFF_NUM):\r\n                calendar_create.add_event(DAY_NUM + 1, schedule_dict[DAY_NUM + 1][i])\r\n\r\n    print(\"Please exit out of the calendar pop-up window once you are done reviewing the duty schedule.\")\r\n    print(\"After closing the calendar pop-up window, you will be prompted to keep the current duty schedule or generate a new version.\")\r\n    calendar_create.show()\r\n\r\n    # determine if scheduling for the current month or the next month\r\n    user_satisfied = input(\"Would you like to KEEP (k) the current calendar or generate a NEW (n) version? [k/n]: \")\r\n    if user_satisfied != 'k' and user_satisfied != 'n':\r\n        print(\"ERROR: Please enter 'k' to keep the current duty schedule or 'n' to generate a new version.\")\r\n        sys.exit(1)\r\n\r\n\r\ncalendar_save_path = MONTH_STRING + \"_\" + str(YEAR) + \"_duty_schedule_\" + BUILDING\r\ncalendar_create.save(\"Schedule/\" + calendar_save_path)\r\n\r\n# reset cumulative weekdays/weekends\r\nprint(\"***Please enter 'n' if this is mid-semester, you should only reset cumulative worked weekdays/weekends to 0 at the beginning or end of a semester.***\")\r\nreset = input(\"Would you like to reset cumulative worked weekdays/weekends for all RAs? [y/n]: \")\r\n\r\n# update history\r\nfor index, RA in enumerate(RA_DETAILS.values()):\r\n    history_master.loc[index, \"Weekdays Total\"] = RA.scheduled_weekdays\r\n    history_master.loc[index, \"Weekends Total\"] = RA.scheduled_weekends\r\n\r\n    if reset == 'y':\r\n        history_master.loc[index, \"Weekdays Total\"] = 0\r\n        history_master.loc[index, \"Weekends Total\"] = 0\r\n\r\n# remove old history file and save new history file for future additions\r\nos.remove(HISTORY_FILE_PATH)\r\nhistory_master.to_excel(HISTORY_FILE_PATH, index=False)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 4ba3bfca8cfda11e41e74f4c8b5f46740253478f)
+++ b/main.py	(date 1636498930705)
@@ -46,7 +46,7 @@
 
 # schedule bounds - useful for partial months of duty scheduling
 SCHEDULE_START_DAY = 1
-MONTH_END_DAY = NUM_DAYS_MONTH
+MONTH_END_DAY = 15 #NUM_DAYS_MONTH
 
 # dictionary to hold names of RA scheduled for each date
 schedule_dict = {}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.8 (RA_Duty_Scheduler)\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 4ba3bfca8cfda11e41e74f4c8b5f46740253478f)
+++ b/.idea/misc.xml	(date 1634909217193)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8 (RA_Duty_Scheduler)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (RA_Duty_Scheduler_39)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/RA_Duty_Scheduler.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.8 (RA_Duty_Scheduler)\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/RA_Duty_Scheduler.iml b/.idea/RA_Duty_Scheduler.iml
--- a/.idea/RA_Duty_Scheduler.iml	(revision 4ba3bfca8cfda11e41e74f4c8b5f46740253478f)
+++ b/.idea/RA_Duty_Scheduler.iml	(date 1634909217181)
@@ -4,7 +4,7 @@
     <content url="file://$MODULE_DIR$">
       <excludeFolder url="file://$MODULE_DIR$/venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.8 (RA_Duty_Scheduler)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.9 (RA_Duty_Scheduler_39)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
